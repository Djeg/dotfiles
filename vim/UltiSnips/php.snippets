global !p

def namespace(snip, path):
	import os
	namespace = pathToNamespace(path)
	if (len(namespace) == 0):
		return ''
	return os.linesep + snip.mkline('namespace ' + namespace + ';') + os.linesep

def pathToNamespace(path):
	import re
	path = path.replace('/', '\\')
	path = re.sub(r'\b[^\\]*\Z', '', path)
	path = path.strip('\\')
	return re.sub(r'\A(\b[^A-Z][^\\]*\\)*', '', path)

endglobal

snippet cl "Display a class" !b
<?php

`!p snip.rv = namespace(snip, path)`

class `!p snip.rv = snip.basename` $1
{
    ${0://implementation ...}
}
endsnippet

snippet acl "Display abstract class" !b
<?php

`!p snip.rv = namespace(snip, path)`

abstract class `!p snip.rv = snip.basename` $1
{
    ${0://implementation ...}
}
endsnippet

snippet it "Generate an interface skeleton" !b
<?php

`!p snip.rv = namespace(snip, path)`

interface `!p snip.rv = snip.basename` $1
{
    ${0://implementation ...}
}
endsnippet

snippet fun "A simple function snippet" !b
${1:public} function ${2:name}(${3:\$value})
{
    ${0://some code here ...}
}
endsnippet

snippet funi "Add a simple mehod signature" !b
public function ${1:name}(${3:\$args});
endsnippet

snippet attr "Display an attribute" !b
${1:public} \$${2:value};
endsnippet

snippet use "Use statement" !b
use ${1:Class};
endsnippet

snippet getset "Generate getter and setter" !b
public function get${1/(.*)/\u$1/}()
{
    return \$this->$1;
}

public function set${1/(.*)/\u$1/}(\$$1)
{
    \$this->$1 = \$$1;

    return \$this;
}
endsnippet

snippet getsets "Generate getters and setters" !b
public function add${1/(.*)/\u$1/}(\$$1)
{
    \$this->$2->add($1);
    
    return \$this;
}

public function get${1/(.*)/\u$1/}(\$$1)
{
    foreach (\$this->$2 as \$value) {
        if (\$value${3: === \$$1}) {

            return \$value;
        }
    }

    return null;
}

public function ${4:has}${1/(.*)/\u$1/}(\$$1)
{
    foreach (\$this->$2 as \$value) {
        if (\$value$3) {
            
            return true;
        }
    }

    return false;
}

public function remove${1/(.*)/\u$1/}(\$$1)
{
    foreach (\$thhis->$2 as \$key => \$value) {
        if (\$value$3) {
            \$this->$2->remove(\$key);

            return \$this;
        }
    }

    return \$this;
}
endsnippet

snippet docattr "Generate doctrine attribute" !b
/**
 * @var ${1:Type} \$$2
 * @ORM\\${3:Column()}
 */
private \$${2:name};
endsnippet

snippet ormcl "Generate a dotrine ORM class" !b
<?php

`!p snip.rv = namespace(snip, path)`

use Doctrine\ORM\Mapping as ORM;

/**
 * @ORM\Entity
 * @ORM\Table(name="$1")
 */
class `!p snip.rv = snip.basename` $2
{
    /**
     * @ORM\Id
     * @ORM\Column(type="integer")
     * @ORM\GeneratedValue(strategy="AUTO")
     */
    private \$id;

    $0
}
endsnippet

snippet ormrepo "Generate a doctrine repository" !b
<?php

`!p snip.rv = namespace(snip, path)`

use Doctrine\ORM\EntityRepository;

class `!p snip.rv = snip.basename` extends EntityRepository
{
}
endsnippet

snippet radrepo "Generate a RabBundle repository" !b
<?php

`!p snip.rv = namespace(snip, path)`

use Knp\RadBundle\Doctrine\EntityRepository;

class `!p snip.rv = snip.basename` extends EntityRepository
{
}
endsnippet

snippet author "Generate an author doc" !b
@author David Jegat <david.jegat@gmail.com>
endsnippet

snippet gearsfile "Generate a corect gears head file" !b
/*
 * This file is litle piece of GearsAdminBundle Package.
 *
 * (c) david jegat <david.jegat@gmail.com>
 *
 * This code is under the MIT licence. For the full copyright and
 * licence please read the LICENSE file distributed with this package.
 */

endsnippet

snippet speccl "Generate a phpspec class" !b
<?php

namespace spec\${1:Namespace};

use PhpSpec\ObjectBehavior;

class ${2:ClassName} extends ObjectBehavior
{
   function it_should_be_initializable()
   {
        \$this->shouldHaveType('${1:Namespace}\${2:ClassName}');    
   }
}
endsnippet

snippet dd "Die and dump a variable" !b
die(var_dump(\$${1:var}));
endsnippet

snippet th "this" !b
\$this->$0
endsnippet
